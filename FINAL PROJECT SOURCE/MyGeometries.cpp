// Use the static library (so glew32.dll is not needed):
#define GLEW_STATIC
#include <GL/glew.h> 
#include <GLFW/glfw3.h>

#include "LinearR3.h"
#include "LinearR4.h"
#include "MathMisc.h"

#include "MyGeometries.h"
#include "FinalProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"
#include "GlGeomTorus.h"

// Material to underlie a texture map.
phMaterial materialUnderTexture;

// Information for loading textures
const int NumTextures = 22;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
    "snorlax_body.bmp", // 0
    "snorlax_HEAD.bmp",
    "road.bmp",
    "concrete_base.bmp",
    "flowers.bmp",
    "wall_temp.bmp",    // 5
    "fence.bmp",
    "gate.bmp",
    "ceramics.bmp",
    "roof_ent.bmp",
    "ground.bmp",        //10
    "green_tile.bmp",
    "dark_oak.bmp",
    "curb.bmp",
    "light_oak.bmp",
    "map.bmp",            //15
    "blue.bmp",
    "window.bmp",
    "grass.bmp",
    "lanturn.bmp",
    "lanturn_blue.bmp",
    "cherry.bmp"
};

// For spheres and a cylinder and a torus (Torus is currently not used.)
GlGeomSphere texSphere(4, 4);
GlGeomCylinder texCylinder(4, 4, 4);
GlGeomTorus texTorus(4, 4, 0.75);

// General data helping with setting up VAO (Vertex Array Objects)
//    and Vertex Buffer Objects.
const int NumObjects = 12;
const int iFloor = 0;
const int iFloor1 = 1;
const int iFillGround = 2;            // RESERVED FOR USE BY 155A PROJECT
const int iLawn1 = 3;
const int iLawn2 = 4;
const int iLawn11 = 5;
const int iLawn21 = 6;
const int map =7;
const int mapFrame = 8;
const int mapf = 9;
const int mapFramef = 10;
const int village = 11;

const int spawnX = 0;
const int spawnY = 0.5;
const int spawnZ = 20;
const double snorlaxBodyHeight = 1.2;
const double snorlaxTopHeight = 0.7;

unsigned int myVBO[NumObjects];  // a Vertex Buffer Object holds an array of data
unsigned int myVAO[NumObjects];  // a Vertex Array Object - holds info about an array of vertex data;
unsigned int myEBO[NumObjects];  // a Element Array Buffer Object - holds an array of elements (vertex indices)

// This sets up for texture maps. It is called only once
void SetupForTextures()
{
    // This material goes under the textures.
    // IF YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE FOR DIFFERENT GEOMETRIES
    materialUnderTexture.EmissiveColor.Set(0.1, 0.1, 0.1);
    materialUnderTexture.SpecularColor.Set(0.4, 0.4, 0.4);
    materialUnderTexture.AmbientColor.Set(0.25, 0.225, 0.175);
    materialUnderTexture.DiffuseColor.Set(0.32,0.24, 0.24);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 40.0;

    // Load texture maps
    RgbImage texMap;

    glUseProgram(shaderProgramBitmap);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);
    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
#if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the shaderProgramBitmap uses the GL_TEXTURE_0 texture.
    glUseProgram(shaderProgramBitmap);
    glUniform1i(glGetUniformLocation(shaderProgramBitmap, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}

void MySetupSurfaces() {

    texSphere.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texCylinder.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texTorus.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);

    // Initialize the VAO's, VBO's and EBO's for the ground plane, the back wall
    // and the surface of rotation. Gives them the "vertPos" location,
    // and the "vertNormal"  and the "vertTexCoords" locations in the shader program.
    // No data is loaded into the VBO's or EBO's for the circular surface until the "Remesh"
    //   routines is called

    glGenVertexArrays(NumObjects, &myVAO[0]);
    glGenBuffers(NumObjects, &myVBO[0]);
    glGenBuffers(NumObjects, &myEBO[0]);

    check_for_opengl_errors();      // Watch the console window for error messages!
}

void MyRemeshGeometries()
{
    // IT IS NOT NECESSARY TO REMESH EITHER THE FLOOR OR THE BACK WALL
    // YOU DO NOT NEED TO CHANGE THIS FOR PROJECT #6.

    texSphere.Remesh(meshRes, meshRes);
    texTorus.Remesh(meshRes, meshRes);

    check_for_opengl_errors();      // Watch the console window for error messages!
}

// **********************************************
// MODIFY THIS ROUTINE TO RENDER THE FLOOR, THE BACK WALL,
//    AND THE SPHERES AND THE CYLINDER. -- WITH TEXTURES
// **********************************************
void MyRenderMap() {
    float matEntries[16];       // Temporary storage for floats

    int indframe = mapFrame;
    int indM = map;
    if (mapFull) {
        indM = mapf;
        indframe = mapFramef;
    }

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[indframe]);
    materialUnderTexture.LoadIntoShaders();
    viewMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[indM]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);
    glUniform1i(applyTextureLocation, true);
    glEnable(GL_POLYGON_OFFSET_FILL);
    glPolygonOffset(1.0, 1.0);
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);
}
void MyRenderGeometries() {
    float matEntries[16];
    renderTempleLawn();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iFillGround]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[10]);
    glUniform1i(applyTextureLocation, true);
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
 
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iFloor]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[2]);
    glUniform1i(applyTextureLocation, true);
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iFloor1 ]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
 
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iLawn1]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iLawn11]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iLawn2]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iLawn21]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[village]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);
    glBindTexture(GL_TEXTURE_2D, TextureNames[18]);     // Choose Earth image texture
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    renderTemple();
    renderGateWall();
    renderBuilding1();
    renderBuilding2();
    renderBuilding3();
    renderCurb();
    MyRenderMap();
    renderTree();

    if (renderFloorOnly) {
        return;
    }

    renderChar();
    check_for_opengl_errors();      // Watch the console window for error messages!
}

void renderChar() {

    float matEntries[16];       // Temporary storage for floats
    LinearMapR4 matDemo = viewMatrix;
    matDemo.Mult_glTranslate(spawnX, spawnY + snorlaxBodyHeight, spawnZ);
    matDemo.Mult_glScale(snorlaxBodyHeight, snorlaxBodyHeight, snorlaxBodyHeight);
    matDemo.Mult_glRotate(faceDir * PI/360.0f + PI/2 -0.13, 0, 1, 0);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[0]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                              // Render the sphere
    texSphere.Remesh(meshRes, meshRes);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(spawnX, spawnY + snorlaxBodyHeight*2 + snorlaxTopHeight*0.6f, spawnZ);
    matDemo.Mult_glScale(snorlaxTopHeight, snorlaxTopHeight, snorlaxTopHeight);
    matDemo.Mult_glRotate(faceDir*PI / 360.0f + PI/2, 0, 1, 0);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[1]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();
    texSphere.Remesh(meshRes, meshRes);

    // arm right
    if (!faceSide) {
        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX + 1.3, spawnY + 1.3 * snorlaxBodyHeight, spawnZ);
        LinearMapR4 mat = matDemo;
        mat.Mult_glRotate(-250 * PI / 360, 0, 0, 1);
        mat.Mult_glRotate(-0.45 * cos(10 * armTime), 1, 0, 0);
        mat.Mult_glScale(0.4, 0.9, 0.4);         // Nonuniform scaling  
        glBindTexture(GL_TEXTURE_2D, TextureNames[16]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        mat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();

        // arm left
        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX - 1.3, spawnY + 1.3 * snorlaxBodyHeight, spawnZ);
        mat = matDemo;
        mat.Mult_glRotate(250 * PI / 360, 0, 0, 1);
        mat.Mult_glRotate(0.45 * cos(10 * armTime), 1, 0, 0);
        mat.Mult_glScale(0.4, 0.9, 0.4);         // Nonuniform scaling 
        mat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();

        // left ear
        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX - 0.2, spawnY +2.6* snorlaxBodyHeight, spawnZ);
        mat = matDemo;
        mat.Mult_glRotate(-270 * PI / 360, 0, 0, 1);
        mat.Mult_glScale(0.25, 0.6, 0.25);        // Nonuniform scaling  
        glBindTexture(GL_TEXTURE_2D, TextureNames[16]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        mat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();

        // right ear
        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX + 0.2, spawnY + 2.6 * snorlaxBodyHeight, spawnZ);
        mat = matDemo;
        mat.Mult_glRotate( 270 * PI / 360, 0, 0, 1);
        mat.Mult_glScale(0.25, 0.6, 0.25);        // Nonuniform scaling  
        glBindTexture(GL_TEXTURE_2D, TextureNames[16]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        mat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();

        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX + 1, spawnY + 0.2 * snorlaxBodyHeight, spawnZ);
        mat = matDemo;
        mat.Mult_glRotate(250 * PI / 360, 0, 0, 1);
        mat.Mult_glRotate(0.75 * cos(10 * armTime), 0, 1, 0);
        mat.Mult_glScale(0.6, 0.2, 0.4);         // Nonuniform scaling 
        mat.DumpByColumns(matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose Earth image texture
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();

        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX - 1, spawnY + 0.2 * snorlaxBodyHeight, spawnZ);
        mat = matDemo;
        mat.Mult_glRotate(250 * PI / 360, 0, 0, 1);
        mat.Mult_glRotate(-0.75 * cos(10 * armTime), 0, 1, 0);
        mat.Mult_glScale(0.6, 0.2, 0.4);         // Nonuniform scaling  
        mat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();
    }
    else {
        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX, spawnY + 1.3 * snorlaxBodyHeight, spawnZ-1.3);
        LinearMapR4 mat = matDemo;
        mat.Mult_glRotate(-250 * PI / 360, 1, 0, 0);
        mat.Mult_glRotate(-0.45 * cos(10 * armTime), 0, 0, 1);
        mat.Mult_glScale(0.4, 0.9, 0.4);         // Nonuniform scaling  
        glBindTexture(GL_TEXTURE_2D, TextureNames[16]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        mat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();

        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX, spawnY + 1.3 * snorlaxBodyHeight, spawnZ + 1.3);
        mat = matDemo;
        mat.Mult_glRotate(250 * PI / 360, 1, 0, 0);
        mat.Mult_glRotate(-0.45 * cos(10 * armTime), 0, 0, 1);
        mat.Mult_glScale(0.4, 0.9, 0.4);         // Nonuniform scaling  
        glBindTexture(GL_TEXTURE_2D, TextureNames[16]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        mat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();

        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX, spawnY + 0.2 * snorlaxBodyHeight, spawnZ-1);
        mat = matDemo;
        mat.Mult_glRotate(250 * PI / 360, 1, 0, 0);
        mat.Mult_glRotate(0.75 * cos(10 * armTime), 0, 1, 0);
        mat.Mult_glScale(0.6, 0.2, 0.4);         // Nonuniform scaling 
        mat.DumpByColumns(matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose Earth image texture
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();

        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX, spawnY + 0.2 * snorlaxBodyHeight, spawnZ+1);
        mat = matDemo;
        mat.Mult_glRotate(250 * PI / 360, 1, 0, 0);
        mat.Mult_glRotate(-0.75 * cos(10 * armTime), 0, 1, 0);
        mat.Mult_glScale(0.6, 0.2, 0.4);         // Nonuniform scaling  
        mat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();

        // left ear
        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX, spawnY + 2.6 * snorlaxBodyHeight, spawnZ + 0.3);
        mat = matDemo;
        mat.Mult_glRotate(-270 * PI / 360, 1, 0, 0);
        mat.Mult_glScale(0.25, 0.6, 0.25);        // Nonuniform scaling  
        glBindTexture(GL_TEXTURE_2D, TextureNames[16]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        mat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();

        // right
        matDemo = viewMatrix;
        matDemo.Mult_glTranslate(spawnX, spawnY + 2.6 * snorlaxBodyHeight, spawnZ - 0.3);
        mat = matDemo;
        mat.Mult_glRotate( 270 * PI / 360, 1, 0, 0);
        mat.Mult_glScale(0.25, 0.6, 0.25);        // Nonuniform scaling  
        glBindTexture(GL_TEXTURE_2D, TextureNames[16]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        mat.DumpByColumns(matEntries);
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        texSphere.Render();
    }

}

void renderTree() {
    int locx = 20;
    int locz = -10;
    LinearMapR4 matDemo = viewMatrix;
    float matEntries[16];
    matDemo.Mult_glTranslate(locx - snorlaxPOSx, 0.5, locz - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 6.0f, 0, 0, 1);
    matDemo.Mult_glScale(0.4, 3, 0.4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);

    // right branch
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(locx - snorlaxPOSx, 2.8, locz - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 5.0f, 0, 0, 1);
    matDemo.Mult_glScale(0.3, 1, 0.3);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(locx - snorlaxPOSx + 0.5, 4.0, locz - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 3.0f, 1, 0, 0);
    matDemo.Mult_glScale(0.2, 0.5, 0.2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(locx - snorlaxPOSx + 0.5, 4.0, locz -1.5- snorlaxPOSy);
    matDemo.Mult_glScale(1, 1, 0.8);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[21]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Remesh(5, 5);
    texSphere.Render();

    // rightmost branch

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(locx - snorlaxPOSx, 3.8, locz - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 0, 1);
    matDemo.Mult_glScale(0.2, 1.3, 0.2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(locx - snorlaxPOSx + 1, 5, locz - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 8.0f, 0, 0, 1);
    matDemo.Mult_glScale(0.2, 0.5, 0.2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(locx - snorlaxPOSx + 1.3, 5.5, locz- snorlaxPOSy);
    matDemo.Mult_glScale(1, 1, 0.8);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[21]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();

    //left branch
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(locx - snorlaxPOSx - 1.9, 3.3, locz - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 3.0f, 0, 0, 1);
    matDemo.Mult_glScale(0.2, 1, 0.2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(locx - snorlaxPOSx - 2.7, 4.2, locz - snorlaxPOSy);
    matDemo.Mult_glScale(1.2, 0.8, 1.2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[21]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(locx - snorlaxPOSx - 1.7, 2.7, locz + 0.7 - snorlaxPOSy);
    matDemo.Mult_glScale(1.2, 0.8, 1.2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[21]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();

    // back branch
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(locx - snorlaxPOSx - 1, 3.3, locz - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 3.0f, 1, 0, 0);
    matDemo.Mult_glScale(0.2, 1, 0.2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(locx - snorlaxPOSx - 1.0, 4.5, -0.7+locz - snorlaxPOSy);
    matDemo.Mult_glScale(0.7, 0.8, 1.2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[21]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();


    texCylinder.Remesh(4, 4, 4);

    texSphere.Remesh(20, 20);
 
}

void renderTempleLawn() {

    float mapVerts[] = {
        // Position              // Normal                  // Texture coordinates
        8.0f, 12.0f, 15.0f,      0.0f, 0.0f, 1.0f,          mapValx - 0.33f, mapValy,         // Back left
        16.0f, 12.0f, 15.0f,      0.0f, 0.0f, 1.0f,         mapValx, mapValy,         // Back right
        16.35f, 9.0f,  15.0f,      0.0f, 0.0f, 1.0f,        mapValx, mapValy - 0.4f,         // Front right
        8.2f, 9.0f,  15.0f,      0.0f, 0.0f, 1.0f,          mapValx - 0.33f, mapValy - 0.4f,         // Front left
    };
    unsigned int mapElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[map]);
    glBindVertexArray(myVAO[map]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(mapVerts), mapVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[map]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(mapElts), mapElts, GL_STATIC_DRAW);

    float mapFrameVerts[] = {
        // Position              // Normal                  // Texture coordinates
        7.8f, 12.2f, 14.8f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Back left
        16.4f, 12.2f, 14.8f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Back right
        16.75f, 8.8f,  14.8f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Front right
        8.0f, 8.8f,  14.8f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Front left
    };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[mapFrame]);
    glBindVertexArray(myVAO[mapFrame]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(mapFrameVerts), mapFrameVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[mapFrame]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(mapElts), mapElts, GL_STATIC_DRAW);

    float mapfVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -8.2f, 12.0f, 15.0f,      0.0f, 0.0f, 1.0f,          mapValx - 0.33f, mapValy,         // Back left
        8.0f, 12.0f, 15.0f,      0.0f, 0.0f, 1.0f,         mapValx, mapValy,         // Back right
        8.6f, 2.0f,  15.0f,      0.0f, 0.0f, 1.0f,        mapValx, mapValy - 0.4f,         // Front right
        -8.8f, 2.0f,  15.0f,      0.0f, 0.0f, 1.0f,          mapValx - 0.33f, mapValy - 0.4f,         // Front left
    };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[mapf]);
    glBindVertexArray(myVAO[mapf]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(mapfVerts), mapfVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[mapf]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(mapElts), mapElts, GL_STATIC_DRAW);

    float mapFramefVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -8.4f, 12.2f, 14.8f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // Back left
        8.4f, 12.2f, 14.8f,      0.0f, 0.0f, 1.0f,          1.0f, 1.0f,         // Back right
        9.0f, 1.8f,  14.8f,      0.0f, 0.0f, 1.0f,          1.0f, 0.0f,         // Front right
        -9.0f, 1.8f,  14.8f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // Front left
    };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[mapFramef]);
    glBindVertexArray(myVAO[mapFramef]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(mapFramefVerts), mapFramefVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[mapFramef]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(mapElts), mapElts, GL_STATIC_DRAW);


    float groundVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -300.0f - snorlaxPOSx, -0.01f, -100.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         300.0f - snorlaxPOSx, -0.01f, -100.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 1.0f,         // Back right
         300.0f - snorlaxPOSx, -0.01f,  100.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 0.0f,         // Front right
        -300.0f - snorlaxPOSx, -0.01f,  100.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int floorElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFillGround]);
    glBindVertexArray(myVAO[iFillGround]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(groundVerts), groundVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFillGround]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);

    float floorVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -2.0f - snorlaxPOSx, 0.0f, -6.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         2.0f - snorlaxPOSx, 0.0f, -6.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 1.0f,         // Back right
         2.0f - snorlaxPOSx, 0.0f,  12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 0.0f,         // Front right
        -2.0f - snorlaxPOSx, 0.0f,  12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };

    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
    glBindVertexArray(myVAO[iFloor]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts), floorVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);

    float floorVerts1[] = {
        // Position              // Normal                  // Texture coordinates
        -2.0f - snorlaxPOSx, 0.0f, 12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Back left
         2.0f - snorlaxPOSx, 0.0f, 12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 0.0f,         // Back right
         2.0f - snorlaxPOSx, 0.0f,  30.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 1.0f,         // Front right
        -2.0f - snorlaxPOSx, 0.0f,  30.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Front left
    };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor1]);
    glBindVertexArray(myVAO[iFloor1]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts1), floorVerts1, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);

    float lawnVerts1[] = {
        // Position              // Normal                  // Texture coordinates
        -13.0f - snorlaxPOSx, 0.0f, -6.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
        -2.0f - snorlaxPOSx, 0.0f, -6.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 1.0f,         // Back right
        -2.0f - snorlaxPOSx, 0.0f,  12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 0.0f,         // Front right
        -13.0f - snorlaxPOSx, 0.0f,  12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int lawnElts1[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iLawn1]);
    glBindVertexArray(myVAO[iLawn1]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(lawnVerts1), lawnVerts1, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iLawn1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(lawnElts1), lawnElts1, GL_STATIC_DRAW);

    float lawnVerts11[] = {
        // Position              // Normal                  // Texture coordinates
        -13.0f - snorlaxPOSx, 0.0f, 12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
        -2.0f - snorlaxPOSx, 0.0f, 12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 1.0f,         // Back right
        -2.0f - snorlaxPOSx, 0.0f,  30.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 0.0f,         // Front right
        -13.0f - snorlaxPOSx, 0.0f,  30.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iLawn11]);
    glBindVertexArray(myVAO[iLawn11]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(lawnVerts11), lawnVerts11, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iLawn11]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(lawnElts1), lawnElts1, GL_STATIC_DRAW);

    float lawnVerts2[] = {
        // Position              // Normal                  // Texture coordinates
        2.0f - snorlaxPOSx, 0.0f, -6.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
        13.0f - snorlaxPOSx, 0.0f, -6.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 1.0f,         // Back right
        13.0f - snorlaxPOSx, 0.0f,  12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 0.0f,         // Front right
        2.0f - snorlaxPOSx, 0.0f,  12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int lawnElts2[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iLawn2]);
    glBindVertexArray(myVAO[iLawn2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(lawnVerts2), lawnVerts2, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iLawn2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(lawnElts2), lawnElts2, GL_STATIC_DRAW);


    float lawnVerts21[] = {
        // Position              // Normal                  // Texture coordinates
        2.0f - snorlaxPOSx, 0.0f, 12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
        13.0f - snorlaxPOSx, 0.0f, 12.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 1.0f,         // Back right
        13.0f - snorlaxPOSx, 0.0f,  30.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 0.0f,         // Front right
        2.0f - snorlaxPOSx, 0.0f,  30.0f - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iLawn21]);
    glBindVertexArray(myVAO[iLawn21]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(lawnVerts21), lawnVerts21, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iLawn21]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(lawnElts2), lawnElts2, GL_STATIC_DRAW);

    float villageVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -48 - snorlaxPOSx, -0.005f, -50 - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         50 - snorlaxPOSx, -0.005f, -50 - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 1.0f,         // Back right
         50 - snorlaxPOSx, -0.005f,  39 - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.5f, 0.0f,         // Front right
        -48 - snorlaxPOSx, -0.005f,  39 - snorlaxPOSy,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[village]);
    glBindVertexArray(myVAO[village]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(villageVerts), villageVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);    // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);                                 // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));    // Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                  // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float))); // Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);                                   // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[village]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);

}

void renderCurb() {
    float matEntries[16];       // Temporary storage for floats
    texCylinder.Remesh(4, 4, 4);
    LinearMapR4 matDemo = viewMatrix;
    // left
    matDemo.Mult_glTranslate(-13 - snorlaxPOSx, 0.4, 2.9 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.5, 9, 0.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[13]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-13 - snorlaxPOSx, 0.4, 20.9 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.5, 9, 0.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[13]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // right
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(13 - snorlaxPOSx, 0.4, 2.9 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.5, 9, 0.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[13]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(13 - snorlaxPOSx, 0.4, 20.9 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.5, 9, 0.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[13]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // front
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate( - snorlaxPOSx, 0.399,-6 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 0, 0, 1);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.5, 13.3, 0.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[13]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // back
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-snorlaxPOSx, 0.399, 30 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 0, 0, 1);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.5, 13.3, 0.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[13]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

}

void renderBuilding1() {

    float matEntries[16];       // Temporary storage for floats

    // bottom base
    LinearMapR4 matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-24 - snorlaxPOSx, 3.0, 10 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(10, 3,10);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // brown edge up
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-24 - snorlaxPOSx, -1, 10 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(10.5, 2, 10.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-24 - snorlaxPOSx, -1.5, 10 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(11, 2, 11);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // top
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-24 - snorlaxPOSx, 6.01, 10 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(11, 0.2, 11);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // triangle top
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-21 - snorlaxPOSx, 3.5, 10 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI /2.0f, 0, 0, 1);
    matDemo.Mult_glScale(7, 2, 7);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // roof
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-20 - snorlaxPOSx, 9.5, 11 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.3, 2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-22 - snorlaxPOSx, 9.5, 11 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.3, 2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);


    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-20 - snorlaxPOSx, 7.7, 13.0 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 5.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.3, 2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-22 - snorlaxPOSx, 7.7, 13.0 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 5.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.3, 2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-20 - snorlaxPOSx, 6.5, 15 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 6.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.3, 2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-22 - snorlaxPOSx, 6.5, 15 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 6.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.3, 2);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // stick out room
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-26.8 - snorlaxPOSx, 3.0, 16 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(6, 3, 6);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // brown edge
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-26.8 - snorlaxPOSx, -1.0, 16 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(6.5, 2, 6.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-26.8 - snorlaxPOSx, -1.5, 16 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(7.0, 2, 7.0);
    matDemo.DumpByColumns(matEntries);                 // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // top edge
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-26.8 - snorlaxPOSx, 6, 16 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(7.0, 0.2, 7.0);
    matDemo.DumpByColumns(matEntries);                 // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // 2nd floor
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-26.8 - snorlaxPOSx, 9.0, 7 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(6, 3, 6);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-26.801 - snorlaxPOSx, 9.0, 12 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(6, 3, 6);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    // top edge

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-26.8 - snorlaxPOSx, 12.0, 7 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(6.5, 0.2, 6.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-26.801 - snorlaxPOSx, 12.0, 12 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(6.5, 0.2, 6.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);
}


void renderBuilding2() {

    float matEntries[16];       // Temporary storage for floats

    // bottom base
    LinearMapR4 matDemo = viewMatrix;
    matDemo.Mult_glTranslate(25 - snorlaxPOSx, 3.0, 10 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(6, 3, 6);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
  
    matDemo.Mult_glTranslate(-1,0, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo.Mult_glTranslate(-1, 0, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    glUniform1i(applyTextureLocation, false);

    // roof 
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(21.50 - snorlaxPOSx, 7, 10 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 0, 1);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(6.0, 0.2, 6.0);
    for (int i = 0; i < 3; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(-1.0, 0, 1.0);
    }

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(28.0 - snorlaxPOSx, 7, 10 - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI/ 4.0f, 0, 0, 1);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(6.0, 0.2, 6.0);
    for (int i = 0; i < 3; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(-1.0, 0, 1.0);
    }
}

void renderBuilding3() {

    float matEntries[16];       // Temporary storage for floats

    // bottom base
    LinearMapR4 matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-30 - snorlaxPOSx, 3.0, -20 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    LinearMapR4 mat = matDemo;
    mat.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    mat.Mult_glScale(7, 3, 7);
    mat.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = mat;
    matDemo.Mult_glTranslate(1, 0, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-30 - snorlaxPOSx, 6.0, -20 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    mat = matDemo;
    mat.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    mat.Mult_glScale(8, 0.2, 8);
    mat.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);    // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = mat;
    matDemo.Mult_glTranslate(1, 0, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);    // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-30 - snorlaxPOSx, 0.2, -20 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    mat = matDemo;
    mat.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    mat.Mult_glScale(8, 0.2, 8);
    mat.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);    // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = mat;
    matDemo.Mult_glTranslate(1, 0, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);    // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

}

void renderTemple() {

    float matEntries[16];       // Temporary storage for floats

    // bottom base
    LinearMapR4 matDemo = viewMatrix; 
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, 1.5, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI/4.0f, 0, 1, 0);
    matDemo.Mult_glScale(11, 1.5, 11);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();       
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);
    
    // edge
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, 2.7, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(11.7, 0.35, 11.7);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    glUniform1i(applyTextureLocation, false);

    // first floor
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, 4.5, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(7, 3, 7);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    glUniform1i(applyTextureLocation, false);

    // 2nd floor
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, 7.5, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(5.5, 3, 5.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, 11.5, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(5.5, 0.2, 5.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderBase();
    glUniform1i(applyTextureLocation, false);

    // stairs
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, 0.2, -5 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(4, 0.3, 4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, -0.2, -4.4 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(4, 0.3, 4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, -0.6, -3.8 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(4, 0.3, 4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, -1.0, -3.2 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(4, 0.3, 4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, -1.4, -2.6 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(4, 0.3, 4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, -1.8, -2.0 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(4, 0.3, 4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, -2.2, -1.4 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(4, 0.3, 4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0 - snorlaxPOSx, -2.6, -0.8 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(4, 0.3, 4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    renderFence();
    renderTempleWall();

    // lights left
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-12 - snorlaxPOSx, 0.5, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.3, 6, 0.3);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(15, 15, 15);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-12 - snorlaxPOSx, 6.5, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(1, 0.2, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-12 - snorlaxPOSx, 1, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.5, 2, 0.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-12 - snorlaxPOSx, 7.7, -13 - snorlaxPOSy);
    matDemo.Mult_glScale(0.8, 1, 0.8);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[19]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-12 - snorlaxPOSx, 8.6, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(1, 0.2, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-12 - snorlaxPOSx, 8.8, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.6, 0.2, 0.6);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    // right light
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(12 - snorlaxPOSx, 0.5, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.3, 6, 0.3);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(15, 15, 15);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(12 - snorlaxPOSx, 6.5, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(1, 0.2, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(12 - snorlaxPOSx, 1, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.5, 2, 0.5);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(12 - snorlaxPOSx, 7.7, -13 - snorlaxPOSy);
    matDemo.Mult_glScale(0.8, 1, 0.8);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[19]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(12 - snorlaxPOSx, 8.6, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(1, 0.2, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(12 - snorlaxPOSx, 8.8, -13 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.6, 0.2, 0.6);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
}

void renderTempleWall() {
    float matEntries[16];       // Temporary storage for floats

    texCylinder.Remesh(4, 4, 4);
    LinearMapR4 fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-5 - snorlaxPOSx, 5.0, -8 - snorlaxPOSy);
    fenceMat.Mult_glScale(0.25, 2.0, 0.25);
    for (int j = 0; j < 2; j++) {
        for (int i = 0; i < 10; i++) {
            if ((i < 4 || i >= 6 && j == 0) || j == 1) {
                fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
                glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
                glBindTexture(GL_TEXTURE_2D, TextureNames[6]);     // Choose Earth image texture
                glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
                texCylinder.RenderSide();
                texCylinder.RenderTop();
                texCylinder.RenderBase();
            }
            fenceMat.Mult_glTranslate(4.43, 0, 0);
        }
        fenceMat = viewMatrix;
        fenceMat.Mult_glTranslate(0 - snorlaxPOSx - 7, 3.5, -19 - snorlaxPOSy);
        fenceMat.Mult_glScale(0.15, 0.5, 0.15);
    }

    // red criss cross vertical
    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-1.15 - snorlaxPOSx, 4.0, -8 - snorlaxPOSy);
    fenceMat.Mult_glScale(0.15, 1.5, 0.15);
        for (int i = 0; i < 7; i++) {
                fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
                glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
                glBindTexture(GL_TEXTURE_2D, TextureNames[7]);     // Choose Earth image texture
                glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
                texCylinder.RenderSide();
                texCylinder.RenderTop();
                texCylinder.RenderBase();
            fenceMat.Mult_glTranslate(2.5, 0, 0);
        }

        // red criss cross horizontal
        fenceMat = viewMatrix;
        fenceMat.Mult_glTranslate(-snorlaxPOSx, 5.0, -8 - snorlaxPOSy);
        fenceMat.Mult_glRotate(PI / 2.0f, 0, 0, 1);
        fenceMat.Mult_glScale(0.15, 1.2, 0.15);

        for (int i = 0; i < 10; i++) {
            fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
            glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
            glBindTexture(GL_TEXTURE_2D, TextureNames[7]);     // Choose Earth image texture
            glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
            texCylinder.RenderSide();
            texCylinder.RenderTop();
            texCylinder.RenderBase();
            fenceMat.Mult_glTranslate(-1.5, 0, 0);
        }

    // wall frame
    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-snorlaxPOSx - 1.25, 4.0, -7.7 - snorlaxPOSy);
    fenceMat.Mult_glScale(0.35, 1.5, 0.35);
    fenceMat.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[6]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-snorlaxPOSx + 1.25, 4.0, -7.7 - snorlaxPOSy);
    fenceMat.Mult_glScale(0.35, 1.5, 0.35);
    fenceMat.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[6]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-snorlaxPOSx, 5.4, -7.69 - snorlaxPOSy);
    fenceMat.Mult_glRotate(PI / 2.0f, 0, 0, 1);
    fenceMat.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    fenceMat.Mult_glScale(0.35, 2.2, 0.35);
    fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[6]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    // floor 1 roof
    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-4-snorlaxPOSx, 7, -7.2 - snorlaxPOSy);
    fenceMat.Mult_glRotate(PI / 6.0f, 1, 0, 0);
    fenceMat.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    fenceMat.Mult_glScale(1.9, 0.2, 1.9);
    for (int i = 0; i < 4; i++) {
        fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        fenceMat.Mult_glTranslate(1.0, 0, -1.0);
    }

    // left roof
    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-5.7 - snorlaxPOSx, 7, -9.5 - snorlaxPOSy);
    fenceMat.Mult_glRotate(PI / 4.0f, 0, 0, 1);
    fenceMat.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    fenceMat.Mult_glScale(1.5, 0.2, 1.5);
    for (int i = 0; i < 4; i++) {
        fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        fenceMat.Mult_glTranslate(1.0, 0, -1.0);
    }

    // right roof
    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(5.7 - snorlaxPOSx, 7, -9.5 - snorlaxPOSy);
    fenceMat.Mult_glRotate(-PI / 4.0f, 0, 0, 1);
    fenceMat.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    fenceMat.Mult_glScale(1.5, 0.2, 1.5);
    for (int i = 0; i < 4; i++) {
        fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        fenceMat.Mult_glTranslate(1.0, 0, -1.0);
    }

    // back roof
    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-4 - snorlaxPOSx, 7, -18 - snorlaxPOSy);
    fenceMat.Mult_glRotate(-PI / 6.0f, 1, 0, 0);
    fenceMat.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    fenceMat.Mult_glScale(1.9, 0.2, 1.9);
    for (int i = 0; i < 4; i++) {
        fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        fenceMat.Mult_glTranslate(1.0, 0, -1.0);
    }

    // top roof
    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-2.75 - snorlaxPOSx, 10.5, -9.4- snorlaxPOSy);
    fenceMat.Mult_glRotate(PI / 6.0f, 1, 0, 0);
    fenceMat.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    fenceMat.Mult_glScale(1.9, 0.2, 1.9);
    for (int i = 0; i < 3; i++) {
        fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        fenceMat.Mult_glTranslate(1.0, 0, -1.0);
    }

    // left roof
    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-4.7 - snorlaxPOSx, 10.5, -11.5 - snorlaxPOSy);
    fenceMat.Mult_glRotate(PI / 4.0f, 0, 0, 1);
    fenceMat.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    fenceMat.Mult_glScale(1.5, 0.2, 1.5);
    for (int i = 0; i < 3; i++) {
        fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        fenceMat.Mult_glTranslate(1.0, 0, -1.0);
    }

    // right roof
    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(4.7 - snorlaxPOSx, 10.5, -11.5 - snorlaxPOSy);
    fenceMat.Mult_glRotate(-PI / 4.0f, 0, 0, 1);
    fenceMat.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    fenceMat.Mult_glScale(1.5, 0.2, 1.5);
    for (int i = 0; i < 3; i++) {
        fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        fenceMat.Mult_glTranslate(1.0, 0, -1.0);
    }

    // back roof
    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-2.75 - snorlaxPOSx, 10.5, -17 - snorlaxPOSy);
    fenceMat.Mult_glRotate(-PI / 6.0f, 1, 0, 0);
    fenceMat.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    fenceMat.Mult_glScale(1.9, 0.2, 1.9);
    for (int i = 0; i < 3; i++) {
        fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        fenceMat.Mult_glTranslate(1.0, 0, -1.0);
    }

}

void renderFence() {

    float matEntries[16];       // Temporary storage for floats

    LinearMapR4 fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(0 - snorlaxPOSx - 7, 3.5, -6 - snorlaxPOSy);
    fenceMat.Mult_glScale(0.15, 0.5, 0.15);
    texCylinder.Remesh(10, 10, 10);
    for (int j = 0; j < 2; j++) {
        for (int i = 0; i < 11; i++) {
            if ((i < 4 || i > 6 && j == 0) || j == 1) {
                fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
                glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
                glBindTexture(GL_TEXTURE_2D, TextureNames[6]);     // Choose Earth image texture
                glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
                texCylinder.RenderSide();
                texCylinder.RenderTop();
                texCylinder.RenderBase();
            }
            fenceMat.Mult_glTranslate(9.43, 0, 0);
        }
        fenceMat = viewMatrix;
        fenceMat.Mult_glTranslate(0 - snorlaxPOSx - 7, 3.5, -19 - snorlaxPOSy);
        fenceMat.Mult_glScale(0.15, 0.5, 0.15);
    }

    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(0 - snorlaxPOSx - 7, 3.5, -6 - snorlaxPOSy);
    fenceMat.Mult_glScale(0.15, 0.5, 0.15);
    for (int j = 0; j < 2; j++) {
        for (int i = 0; i < 9; i++) {
            fenceMat.Mult_glTranslate(0, 0, -9.43);
            fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
            glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
            glBindTexture(GL_TEXTURE_2D, TextureNames[6]);     // Choose Earth image texture
            glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
            texCylinder.RenderSide();
            texCylinder.RenderTop();
            texCylinder.RenderBase();
        }
        fenceMat = viewMatrix;
        fenceMat.Mult_glTranslate(7.2 - snorlaxPOSx, 3.5, -6 - snorlaxPOSy);
        fenceMat.Mult_glScale(0.15, 0.5, 0.15);
    }

    // connecting
    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate( -snorlaxPOSx - 5.0, 3.7, -6 - snorlaxPOSy);
    //fenceMat.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    fenceMat.Mult_glRotate(PI / 2.0f, 0, 0, 1);
    fenceMat.Mult_glScale(0.08, 2.1, 0.08);
    fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[6]);   // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    fenceMat = viewMatrix;
    fenceMat.Mult_glTranslate(-snorlaxPOSx + 5.0, 3.7, -6 - snorlaxPOSy);
    fenceMat.Mult_glRotate(PI / 2.0f, 0, 0, 1);
    fenceMat.Mult_glScale(0.08, 2.1, 0.08);
    fenceMat.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[6]);   // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    glUniform1i(applyTextureLocation, false);

    texCylinder.Remesh(4, 4, 4);
}

void renderGateWall() {

    float matEntries[16];       // Temporary storage for floats

   // front row
    LinearMapR4 matDemo = viewMatrix;
    matDemo.Mult_glTranslate(7.5 - snorlaxPOSx, 2.5, 40 - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(3, 0.5, 3);
    for (int i = 0; i < 10; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate( 1.0,0,-1.0);
    }

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-7.5 - snorlaxPOSx, 2.5, 40 - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(3, 0.5, 3);
    for (int i = 0; i < 10; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(-1.0, 0, +1.0);
    }

    // tilted roof
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-50 - snorlaxPOSx, 5.2, 41 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.2, 2);
    for (int i = 0; i < 37; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[9]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(1.0, 0, -1.0);
    }
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-50 - snorlaxPOSx, 5.2, 39 - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 4.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.2, 2);
    for (int i = 0; i < 37; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[9]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(1.0, 0, -1.0);
    }

    // back row
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-45 - snorlaxPOSx, 2.5, -40 - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 2.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(3, 0.5, 3);
    for (int i = 0; i < 23; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(1.0, 0, -1.0);
    }


    // tilted roof
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-50 - snorlaxPOSx, 5.2, -39 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.2, 2);
    for (int i = 0; i < 37; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[9]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(1.0, 0, -1.0);
    }
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-50 - snorlaxPOSx, 5.2, -41 - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 4.0f, 1, 0, 0);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.2, 2);
    for (int i = 0; i < 37; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[9]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(1.0, 0, -1.0);
    }
    // right
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(50 - snorlaxPOSx, 2.5, 40 - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 2.0f, 0, 0, 1);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    //matDemo.Mult_glRotate(-PI / 2.0f, 0, 0, 1);
    matDemo.Mult_glScale(3, 0.5, 3);
    for (int i = 0; i < 20; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(1.0, 0, -1.0);
    }

    // tilted roof
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(51 - snorlaxPOSx, 5.2, 40 - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 0, 1);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.2, 2);
    for (int i = 0; i < 30; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[9]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(1.0, 0, -1.0);
    }
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(49 - snorlaxPOSx, 5.2, 40 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 0, 1);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.2, 2);
    for (int i = 0; i < 30; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[9]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(1.0, 0, -1.0);
    }

    // left
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-47 - snorlaxPOSx, 2.5, 38 - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 2.0f, 0, 0, 1);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    //matDemo.Mult_glRotate(-PI / 2.0f, 0, 0, 1);
    matDemo.Mult_glScale(3, 0.5, 3);
    for (int i = 0; i < 20; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(1.0, 0, -1.0);
    }

    // tilted roof
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-46 - snorlaxPOSx, 5.2, 40 - snorlaxPOSy);
    matDemo.Mult_glRotate(-PI / 4.0f, 0, 0, 1);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.2, 2);
    for (int i = 0; i < 30; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[9]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(1.0, 0, -1.0);
    }
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-48 - snorlaxPOSx, 5.2, 40 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 0, 1);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(2, 0.2, 2);
    for (int i = 0; i < 30; i++) {
        matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
        glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
        glBindTexture(GL_TEXTURE_2D, TextureNames[9]);     // Choose Earth image texture
        glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
        texCylinder.RenderSide();
        texCylinder.RenderTop();
        texCylinder.RenderBase();
        matDemo.Mult_glTranslate(1.0, 0, -1.0);
    }
    texCylinder.Remesh(4, 4, 4);
    glUniform1i(applyTextureLocation, false);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-7 - snorlaxPOSx, 0, 42 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(1, 0.2, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(15, 15, 15);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-7 - snorlaxPOSx, 1.2, 42 - snorlaxPOSy);
    matDemo.Mult_glScale(0.8, 1, 0.8);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[20]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-7 - snorlaxPOSx, 2.1, 42 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(1, 0.2, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-7 - snorlaxPOSx, 2.5, 42 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.6, 0.2, 0.6);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(7 - snorlaxPOSx, 0, 42 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(1, 0.2, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(15, 15, 15);

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(7 - snorlaxPOSx, 1.2, 42 - snorlaxPOSy);
    matDemo.Mult_glScale(0.8, 1, 0.8);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[20]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(7 - snorlaxPOSx, 2.1, 42 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(1, 0.2, 1);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();

    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(7 - snorlaxPOSx, 2.5, 42 - snorlaxPOSy);
    matDemo.Mult_glRotate(PI / 4.0f, 0, 1, 0);
    matDemo.Mult_glScale(0.6, 0.2, 0.6);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();
    texCylinder.RenderTop();
    texCylinder.RenderBase();
    texCylinder.Remesh(4, 4, 4);
}